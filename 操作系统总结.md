# 1.操作系统引论

## 1.操作系统的主要功能
###1.处理机管理功能
**1.进程控制**
​	当进程运行结束时，应立即撤销进程，以便能及时回收该进程所占用的资源，供其他进程使用。
**2.进程同步**
​	主要任务是为多个进程的运行进行协调，常用的协调方式有①进程互斥方式，指诸进程在对临界资源进行访问时，采用互斥方式；②进程同步方式，指在相互合作去完成共同任务的主进程间，由同步机构对他们的执行次序加以协调。最简单得 实现进程互斥的机制是为每一个临界资源配置一把锁，而实现进程同步时，最常用的是信号量机制。
**3.进程通信**	
​	当相互合作的进程处于同一计算机时，通常在它们之间采用直接通信的方式，即由原进程发送命令直接将消息挂到目标进程的消息队列上，以后有目标进程利用接受命令从消息队列取出消息。
**4.调度**
​	①作业调度：从后备队列中按照一定的算法选择出若干个作业，为他们分配运行所需的资源，再将作业调入内存之后，分别为他们建立进程，使它们都成为可能获得处理机的就绪进程，并将他们插入到就绪队列中。
​	②进程调度：从就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为它设置运行现场，使其投入运行。

### 2.存储器管理功能

**1.内存分配**
内存分配的主要任务：
(1)为每道程序分配内存空间;
(2)提高存储器的利用率，尽量减少不可用的内存空间;
(3)允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需求

| 内存分配方式 |                   说明                   |
| :----: | :------------------------------------: |
| 静态分配方式 | 作业装入时内存空间确定，装入后的整个运行期间**不允许**再申请新的内存空间 |
| 动态分配方式 | 作业装入时内存空间确定，装入后的整个运行期间**允许**再申请新的内存空间  |
**2.内存保护**
主要任务:
​	(1)确保每道用户程序都仅在自己的内存空间内运行
​	(2)绝不允许用户程序访问系统的程序和数据,也绝不允许用户程序转移到非共享的其他用户程序中执行.
简单的内存保护机制:设置两个界限存储器,分别用于存放正在执行程序的上界和下界.在程序运行时,系统需对每条指令所要访问的地址进行检查,如果发生越界.便发出越界中断请求,以停止该程序的运行.
**3.地址映射**
​	将地址空间中的逻辑地址转化为内存空间中与之对应的物理地址.
**4.内存扩充**
​	借助于虚拟存储技术,从逻辑上扩充内存容量
内存扩充用于实现下属功能:
(1)请求调入功能:系统允许仅在装入部分程序和数据的情况下,便能启动该程序.在程序运行过程中,若发现要继续运行时所需的程序和数据尚未装入内存,可向OS发出请求,由OS从磁盘中将所需部分调入内存,以便继续运行.
(2)置换功能:若发现在内存中已无足够的空间来装入需要调入的程序和数据时,系统应将内存中的一部分暂时不用的程序和数据调至硬盘上,以腾出内存空间,然后再将所需调入的程序和数据调入内存.



### 线程

产生死锁的原因主要是： 
（1） 因为系统资源不足。 
（2） 进程运行推进的顺序不合适。 
（3） 资源分配不当等。 
产生死锁的四个必要条件： 
（1）互斥条件：一个资源每次只能被一个进程使用。 
（2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
（3）不可剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 
（4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

**避免死锁：** 
死锁的预防是通过破坏产生条件来阻止死锁的产生，但这种方法破坏了系统的并行性和并发性。 
死锁产生的前三个条件是死锁产生的必要条件，也就是说要产生死锁必须具备的条件，而不是存在这3个条件就一定产生死锁，那么只要在逻辑上回避了第四个条件就可以避免死锁。 
避免死锁采用的是允许前三个条件存在，但通过合理的资源分配算法来确保永远不会形成环形等待的封闭进程链，从而避免死锁。该方法支持多个进程的并行执行，为了避免死锁，系统动态的确定是否分配一个资源给请求的进程。 
**预防死锁**：具体的做法是破坏产生死锁的四个必要条件之一。

银行家算法：该算法需要检查申请者对各类资源的最大需求量，如果现存的各类资源可以满足当前它对各类资源的最大需求量时，就满足当前的申请。换言之，仅当申请者可以在一定时间内无条件归还它所申请的全部资源时，才能把资源分配给它。这种算法的主要问题是，要求每个进程必须先知道资源的最大需求量，而且在系统的运行过程中，考察每个进程对各类资源的申请需花费较多的时间。另外，这一算法本身也有些保守，因为它总是考虑最坏可能的情况。

